
maximtop [8:02 PM]
```function cons($x, $y)
{
    return function ($func) use ($x, $y) {
        return $func($x, $y);
    };
}

function car($pair)
{
    // BEGIN (write your solution here)
    return $pair(function($x, $y) {
        return $x;
    });
    // END
}

function cdr($pair)
{
    // BEGIN (write your solution here)
    return $pair(function($x, $y) {
        return $y;
    });
    // END
}```
Можно мне объяснить на пальцах как это работает? В поиске не смог найти, такой беседы.

eye [8:06 PM]
ммм, если впервые с этим сталкиваетесь, то наверное много неясных моментов, с чего начать? )

maximtop [8:06 PM]
Я понимаю, что $pair после
```$pair = cons(5, 10);```
- это функция, в которой есть значения 5 и 10(edited)

[8:07]
Не понимаю вот этого
```$pair(function($x, $y))```
- почему $x принимает значение 5?(edited)

eye [8:10 PM]
почему $x принимает значение 5 внутри функции, вызванной в pair?

maximtop [8:11 PM]
Да


Prowd BOT [8:12 PM]
@eye now has 5 points!
+1 from @kirill.mokevnin
View the leaderboard

kirill.mokevnin [8:13 PM]
авансом :wink:

eye [8:14 PM]
Потому что $pair вызывает переданную функцию от параметров $x и $y. А при создании функции $pair эти значения $x и $y были зафиксированы с помощью замыкания (use), в нашем случае это значения 5 и 10. В итоге пока функция существует, она видит что лежит в этих $x и $y. Т.к. при создании функции эти участки памяти были созданы и никуда больше не передавались, то только функция $pair их и видит, и ничто вокруг на них не может повлиять.(edited)

[8:15]
Зря, я от абстракции отхожу, мыслить на уровне связей между сущностями вроде переменных и функций проще )

kirill.mokevnin [8:18 PM]
тут помогает объяснение изнутри

[8:18]
как подстановки

[8:20]
вот простая функция, работает так, вот мы эту функцию засунули в другую, вычисление не поменялось

[8:20]
и так далее

denis.kozlov [8:22 PM]
Сons играет роль паттерна, запоминающего переданные ему аргументы
то есть он вернет функцию которая "помнит" переданные в cons аргументы
В итоге мы получаем возможность создавать функции построенные по единому шаблону, но с разными значениями(x и y)
Внутри функции которая внутри cons реализуются методы для работы с этими значениями(то есть как раз car и cdr) Она принимает функцию определенную в car и cdr в данном случае, которая просто возвращает одно из значений

eye [8:26 PM]
тогда наверное наоборот надо вести повествование ) $func может быть любой функцией, например,
```$func = function ($x) {
    return $x*5;
}
$func(3) == 15;
```
ее мы можем куда-нибудь передать в другую функцию, например, $bigFunc, которая как-нибудь хитро ее вызывает
```$bigFunc = function ($f, $positive, $negative)  {
    return $f($positive) - $f($negative);
};
$bigFunc($func, 13, 6) == 35; //65-30
```
Следующим шагом, попробуем такие функции генерировать. $funcBuilder
```$funcBuilder = function () {
    return function ($x) {
        return $x*5;
    }
}
$func = $funcBuilder();
$func(3) == 15;
$func2 = $funcBuilder();
$func2(5) == 25;
```
Получается, что мы можем создавать много похожих функций, и нам не надо каждый раз их описывать.
Дальше мы побалуемся с замыканиями. Что это? Это передача каких-то значений из текущего контекста внутрь функции, на все время жизни функции.
```$n = 3;
$func = function($x) use($n) {
    return $x*$n;
}
$func(3) == 9;
$func(7) == 21;
```
И попробуем все это смешать
```$funcBuilder = function ($n) {
    return function ($x) use($n) {
        return $x*$n;
    }
}
$func = $funcBuilder(3);
$func(3) == 9;
$func2 = $funcBuilder(7);
$func2(3) == 21;
$func2(9) == 63;
```
но замыканием можно передать что угодно, и это навсегда запомнится. Возвращаясь к нашим примерам с cons - мы запоминаем значения пары $x и $y. А после вызываем функции, которым эти значения будут поданы в качестве параметров. И car возвращает первый элемент пары (return $x;), а cdr второй (return $y;)(edited)

maximtop [8:29 PM]
Мне кажется, что я понял. Надо было обратить внимание на то, что cons возвращает функцию, которая принимает функцию
``` return function ($func) ```
(edited)

[8:31]
А я видел это таким образом: cons возвращает функцию, которая принимает только аргументы $x, $y(edited)

i.rastypain [8:31 PM]
да, тут как раз вся и фишка в том, что возвращается переданная функция от полученных аргументов

denis.kozlov [8:34 PM]
Функция которую возвращает cons может принимать к примеру переменную  на которую смотрит свитч и возвращает разные значения

i.rastypain [8:34 PM]
ну, как это было в теории к занятию(edited)

denis.kozlov [8:36 PM]
ну да) это к тому что она по разному может действовать)

i.rastypain [8:37 PM]
а в практике избавляются от этого способа. так как при создании нового функционала, необходимо добавлять в конструктор. в практике повышается независимость. можно отдельно писать любые функции. и будет работать всё прекрасно без затрагивания конструктора(edited)

[8:40]
вот на этом у меня щёлкнуло в понимании. структура не зависит от конечной реализации новых функций. можно написать новую функцию, например, вывод на печать (print($pair)), и мне не потребуется модифицировать структуру пары.

eye [8:49 PM]
я там поправил свое последнее сообщение, простыню накатал )

[8:51]
угу, или
```function sum($pair)
{
    return $pair(function($x, $y) {
        return $x+$y;
    });
}

function delta($pair)
{
    return $pair(function($x, $y) {
        return abs($x-$y);
    });
}
```

такие будут прекрасно работать без изменений остального кода.

i.rastypain [8:52 PM]
да. но вот только надо въехать в это)

alex_r [8:53 PM]
@eye: хорошо расписал, аж снова вспомнил и понял :simple_smile:

eye [8:54 PM]
я сильно удивлен :smile: но думаю что перепрыгивание к cons-car-cdr тяжеловато, нужно еще столько же написать чтобы добить всю цепочку с нуля до конца.(edited)
